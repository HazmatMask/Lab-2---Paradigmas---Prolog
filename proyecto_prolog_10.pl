%useSEED(SEMILLA,PISO,TECHO,VALOR).
%META: GENERAR UN VALOR SEUDO ALEATORIO ENTRE LOS VALORES PISO Y TECHO, UTILIZANDO SEMILLA COMO PIVOTE.
%DOMINIO: ENTERO X ENTERO X ENTERO X ENTERO.

useSEED(SEED,FLOOR,ROOF,V_OUT):-set_random(seed(SEED)), V_OUT is (FLOOR+random(ROOF-FLOOR)).

% TDA: SCENE
% COMPOSICION TDA: [ENTERO X ENTERO X ENTERO X LISTA {ENTERO X LISTA DE TRIOS DE ENTEROS} X LISTA {ENTERO X LISTA DE TRIOS DE ENTEROS}]
% ESTRUCTURA TDA: IDENTIFICADOR X ALTO X ANCHO X LISTA {NUMERO DE ALIADOS X LISTA DE ALIADOS} X LISTA {NUMERO DE ALIADOS X LISTA DE ALIADOS}
% ESTRUCTURA DE ALIADO: LISTA [IDENTIFICADOR X POSICION VERTICAL X POSICION HORIZONTAL]

% BASE DE CONOCIMIENTO

% DIFICULTAD: 1

scene(1,5,10,  [4,[1,1,1],[2,1,2],[3,1,3],[4,1,4]],   [2,[1,1,9], [1,1,10]]).
scene(2,5,10,  [4,[1,1,1],[2,1,2],[3,1,3],[4,1,4]],   [4,[1,1,7], [2,1,8],  [3,1,9], [4,1,10]]).
scene(3,5,10,  [4,[1,1,1],[2,1,2],[3,1,3],[4,1,4]],   [5,[1,1,6], [2,1,7],  [3,1,8], [4,1,9], [5,1,10]]).
scene(4,10,12,  [4,[1,1,1],[2,1,2],[3,1,3],[4,1,4]],   [4,[1,1,9], [2,1,10], [3,1,11],[4,1,12]]).
scene(5,10,12,  [4,[1,1,1],[2,1,2],[3,1,3],[4,1,4]],   [6,[1,1,7], [2,1,8],  [3,1,9], [4,1,10],[5,1,11],[6,1,12]]).
scene(6,20,20,  [4,[1,1,1],[2,1,2],[3,1,3],[4,1,4]],   [8,[1,1,13],[2,1,14], [3,1,15],[4,1,16],[5,1,17],[6,1,18],[7,1,19],[8,1,20]]).

% DIFICULTAD: 2

scene(7,5,10,  [3,[1,1,1],[2,1,2],[3,1,4]],   [2,[1,1,9], [1,1,10]]).
scene(8,5,10,  [3,[1,1,1],[2,1,2],[3,1,4]],   [4,[1,1,7], [2,1,8],  [3,1,9], [4,1,10]]).
scene(9,5,10,  [3,[1,1,1],[2,1,2],[3,1,4]],   [5,[1,1,6], [2,1,7],  [3,1,8], [4,1,9], [5,1,10]]).
scene(10,10,12,  [3,[1,1,1],[2,1,2],[3,1,4]],   [4,[1,1,9], [2,1,10], [3,1,11],[4,1,12]]).
scene(11,10,12,  [3,[1,1,1],[2,1,2],[3,1,4]],   [6,[1,1,7], [2,1,8],  [3,1,9], [4,1,10],[5,1,11],[6,1,12]]).
scene(12,20,20,  [3,[1,1,1],[2,1,2],[3,1,4]],   [8,[1,1,13],[2,1,14], [3,1,15],[4,1,16],[5,1,17],[6,1,18],[7,1,19],[8,1,20]]).

% DIFICULTAD: 3

scene(13,5,10,  [2,[1,1,1],[2,1,3]],   [2,[1,1,9], [1,1,10]]).
scene(14,5,10,  [2,[1,1,1],[2,1,3]],   [4,[1,1,7], [2,1,8],  [3,1,9], [4,1,10]]).
scene(15,5,10,  [2,[1,1,1],[2,1,3]],   [5,[1,1,6], [2,1,7],  [3,1,8], [4,1,9], [5,1,10]]).
scene(16,10,12,  [2,[1,1,1],[2,1,3]],   [4,[1,1,9], [2,1,10], [3,1,11],[4,1,12]]).
scene(17,10,12,  [2,[1,1,1],[2,1,3]],   [6,[1,1,7], [2,1,8],  [3,1,9], [4,1,10],[5,1,11],[6,1,12]]).
scene(18,20,20,  [2,[1,1,1],[2,1,3]],   [8,[1,1,13],[2,1,14], [3,1,15],[4,1,16],[5,1,17],[6,1,18],[7,1,19],[8,1,20]]).

% DIFICULTAD: 4

scene(19,5,10,  [1,[1,1,3]],   [2,[1,1,9], [1,1,10]]).
scene(20,5,10,  [1,[1,1,3]],   [4,[1,1,7], [2,1,8],  [3,1,9], [4,1,10]]).
scene(21,5,10,  [1,[1,1,3]],   [5,[1,1,6], [2,1,7],  [3,1,8], [4,1,9], [5,1,10]]).
scene(22,10,12,  [1,[1,1,3]],   [4,[1,1,9], [2,1,10], [3,1,11],[4,1,12]]).
scene(23,10,12,  [1,[1,1,3]],   [6,[1,1,7], [2,1,8],  [3,1,9], [4,1,10],[5,1,11],[6,1,12]]).
scene(24,20,20,  [1,[1,1,3]],   [8,[1,1,13],[2,1,14], [3,1,15],[4,1,16],[5,1,17],[6,1,18],[7,1,19],[8,1,20]]).

% CONSTRUCTOR: NEWSCENE(I,H,W,[Q_A|A_LIST],[Q_E|E_LIST],S_OUT).
% META: CREAR, DADOS DATOS ENTREGADOS EN BASE DE CONOCIMIENTO, UNA ESTRUCTURA SCENE.
% DOMINIO: ENTERO X ENTERO X LISTA {ENTERO X LISTA DE PERSONAJES} X LISTA {ENTERO X LISTA DE PERSONAJES} X ESCENA ASOCIADA.

newScene(I,H,W,[Q_A|A_LIST],[Q_E|E_LIST],S_OUT):-scene(I,H,W,[Q_A|A_LIST],[Q_E|E_LIST]),S_OUT = [I,H,W,[Q_A|A_LIST],[Q_E|E_LIST]],!.

% PERTENENCIA:
% META: DETERMINAR SI UN ELEMENTO CORRESPONDE A UN ESCENARIO.
% DOMINIO: ESTRUCTURA SCENE.

isScene(S_IN):-length(S_IN,5), [I,H,W,_,[Q_E|E_L]] = S_IN,(number(I),I > 0),(number(H),H > 0),(number(W),W > 0),(number(Q_E),Q_E > 0,is_list(E_L),length(E_L,Q_E)).

% SELECTORES:
% META: DETERMINAR UNA DE LAS VARIOS COMPONENTES DE UNA ESTRUCTURA SCENE.

% DOMINIO DE GETID, GETHEIGHT, GETWIDTH: ENTERO X SCENE.

getID(ID,S_IN):-[ID,_,_,_,_] = S_IN.

getHEIGHT(H,S_IN):-[_,H,_,_,_] = S_IN.

getWIDTH(W,S_IN):-[_,_,W,_,_] = S_IN.

% RECURSIVECHAR(E_ID,LIST,CHAR)
% META: EXTRAER UN PERSONAJE, CORRESPONDIENTE AL IDENTIFICADOR ENTREGADO, DESDE UNA LISTA DE PERSONAJES.
% DOMINIO: ENTERO, LISTA DE PERSONAJES, PERSONAJES.

recursiveCHAR(_,[],_):-false.
recursiveCHAR(E_ID,[[E_I,E_H,E_W]|_],CHAR):-E_ID = E_I,CHAR = [E_I,E_H,E_W].
recursiveCHAR(E_ID,[[E_I,_,_]|TAIL],CHAR):-E_ID \= E_I,recursiveCHAR(E_ID,TAIL,CHAR).

% GETALLYMODULE(A,SCENE)
% META: EXTRAER EL MODULO DE PERSONAJES ALIADOS (CANTIDAD X LISTA DE ALIADOS)
% DOMINIO: LISTA X SCENE

getALLYmodule(A,S_IN):-[_,_,_,A,_] = S_IN.

% GETALLYNUMBER(Q,SCENE)
% META: EXTRAER LA CANTIDAD DE ALIADOS PRESENTES EN UN ESCENARIO.
% DOMINIO: ENTERO X SCENE

getALLYnumber(Q_A,S_IN):-getALLYmodule([Q_A|_],S_IN).

% GETALLYLIST(L,SCENE)
% META: EXTRAER LA LISTA DE ALIADOS PRESENTES EN UN ESCENARIO.
% DOMINIO: LISTA X SCENE

getALLYlist(A_L,S_IN):-getALLYmodule([_|A_L],S_IN).

% GETALLY(A,SCENE)
% META: EXTRAER ALIADO ASOCIADO A IDENTIFICADOR DADO DESDE UN ESCENARIO.
% DOMINIO: ENTERO X SCENE X ALIADO

getALLY(A_ID,S_IN,A):-getALLYnumber(Q_A,S_IN),A_ID =< Q_A,getALLYlist(A_L,S_IN),recursiveCHAR(A_ID,A_L,A),!.

% GETENEMYMODULE(E,SCENE)
% META: EXTRAER EL MUDO DE PERSONAJES ENEMIGOS (CANTIDAD X LISTA DE ENEMIGOS)
% DOMINIO: LISTA X SCENE

getENEMYmodule(E,S_IN):-[_,_,_,_,E] = S_IN.

% GETENEMYNUMBER(Q,SCENE)
% META: EXTRAER LA CANTIDAD DE ENEMIGOS PRESENTES EN UN ESCENARIO.
% DOMINIO: ENTERO X SCENE

getENEMYnumber(Q_E,S_IN):-getENEMYmodule([Q_E|_],S_IN).

% GETENEMYLIST(L,SCENE)
% META: EXTRAER LA LISTA DE ENEMIGOS PRESENTES EN UN ESCENARIO.
% DOMINIO: LISTA X SCENE

getENEMYlist(E_L,S_IN):-getENEMYmodule([_|E_L],S_IN).

% GETENEMY(A,SCENE)
% META: EXTRAER ENEMIGO ASOCIADO A IDENTIFICADOR DADO DESDE UN ESCENARIO.
% DOMINIO: ENTERO X SCENE X PERSONAJE

getENEMY(E_ID,S_IN,E):-getENEMYnumber(Q_E,S_IN),E_ID =< Q_E,getENEMYlist(E_L,S_IN),recursiveCHAR(E_ID,E_L,E),!.

% MODIFICADORES:

% MODID(SCENE_IN, ID, SCENE_OUT)
% META: MODIFICAR IDENTIFICADOR ASOCIADO A ESCENARIO DADO.
% DOMINIO: SCENE X ENTERO X SCENE

modID(S_IN,ID,S_OUT):-[_|T] = S_IN, [ID|T] = S_OUT.

% MODHEIGHT(SCENE_IN, H, SCENE_OUT)
% META: MODIFICAR ALTURA ASOCIADO A ESCENARIO DADO.
% DOMINIO: SCENE X ENTERO X SCENE

modHEIGHT(S_IN,HEIGHT,S_OUT):-[I,_|T] = S_IN, [I,HEIGHT|T] = S_OUT.

% MODWIDTH(SCENE_IN, W, SCENE_OUT)
% META: MODIFICAR ANCHO ASOCIADO A ESCENARIO DADO.
% DOMINIO: SCENE X ENTERO X SCENE

modWIDTH(S_IN,WIDTH,S_OUT):-[I,H,_|T] = S_IN, [I,H,WIDTH|T] = S_OUT.

% MODALLYMODULE(SCENE_IN, A, SCENE_OUT)
% META: MODIFICAR MODULO DE ALIADOS ASOCIADO A ESCENARIO DADO.
% DOMINIO: SCENE X LISTA X SCENE

modALLYmodule(S_IN,ALLY,S_OUT):-[I,H,W,_|T] = S_IN, [I,H,W,ALLY|T] = S_OUT.

% MOVECHARRIGHT(ALLY_IN,ALLY_OUT)
% META: AUMENTAR EN UNO LA POSICION HORIZONTAL DE UN ALIADO.
% DOMINIO: PERSONAJE X PERSONAJE

moveCHARright([ID,H,W],A_OUT):-W_OUT is W+1, A_OUT = [ID,H,W_OUT].

% MOVECHARLEFT(ALLY_IN,ALLY_OUT)
% META: DISMINUIR EN UNO LA POSICION HORIZONTAL DE UN ALIADO.
% DOMINIO: PERSONAJE X PERSONAJE

moveCHARleft([ID,H,W],A_OUT):-W_OUT is W-1, A_OUT = [ID,H,W_OUT].

% MOD_RECURSIVECHAR(LIST,CHARACTER,LIST)
% META: RECORRER Y CLONAR UNA LISTA, MODIFICANDO AQUEL ELEMENTO/PERSONAJE EN ELLA CUYO IDENTIFICADOR COINCIDA CON EL PERSONAJE OTORGADO.
% DOMINIO: LISTA DE PERSONAJES X PERSONAJE X LISTA DE PERSONAJES

mod_recursiveCHAR([],_,[]):-!.
mod_recursiveCHAR([HEAD_IN|TAIL_IN],CHAR_IN,[HEAD_OUT|TAIL_OUT]):-number(HEAD_IN),HEAD_IN = HEAD_OUT,mod_recursiveCHAR(TAIL_IN,CHAR_IN,TAIL_OUT).
mod_recursiveCHAR([[O_ID,_,_]|O_TAIL],[C_ID,C_H,C_W],[COPY_HEAD|COPY_TAIL]):-C_ID = O_ID, COPY_HEAD = [C_ID,C_H,C_W], mod_recursiveCHAR(O_TAIL,[C_ID,C_H,C_W],COPY_TAIL),!.
mod_recursiveCHAR([[O_ID,O_H,O_W]|O_TAIL],[C_ID,C_H,C_W],[COPY_HEAD|COPY_TAIL]):-C_ID \= O_ID, COPY_HEAD = [O_ID,O_H,O_W], mod_recursiveCHAR(O_TAIL,[C_ID,C_H,C_W],COPY_TAIL),!.

% MODENEMYMODULE(SCENE_IN,CHARACTER,SCENE_OUT)
% META: MODIFICAR MODULO DE ENEMIGOS EN ESCENARIO DADO.
% DOMINIO: SCENE X LISTA X SCENE

modENEMYmodule(S_IN,ENEMY,S_OUT):-[I,H,W,A,_] = S_IN, [I,H,W,A,ENEMY] = S_OUT.

% CREATESCENE(H,W,E,D,SEED,S_OUT)
% META: CREAR, DADOS PARAMETROS INGRESADOS Y SU CORRESPONDENCIA CON BASE DE CONOCIMIENTO, UN ESCENARIO. PARTICULARMENTE, DE ENTREGARSE UNA SEMILLA, SE ENTREGA ALEATORIAMENTE UNO DE LOS ESCENARIOS CONTENIDOS EN BASE DE CONOCIMIENTO.

createScene(_,_,_,_,SEED,S_OUT):- number(SEED),useSEED(SEED,1,24,V_OUT),newScene(V_OUT,_,_,_,_,S_OUT),!.

createScene(H,W,E,D,_,S_OUT):-    number(E),number(W),E < W/2,number(H),number(D),A is 5-D,((D < 2,newScene(_,H,W,[4|_],[E|_],S_OUT));(D > 3, newScene(_,H,W,[1|_],[E|_],S_OUT));(newScene(_,H,W,[A|_],[E|_],S_OUT))),!.
createScene(_,W,E,D,_,S_OUT):-    number(E),number(W),E < W/2,number(D),A is 5-D,((D < 2,newScene(_,_,W,[4|_],[E|_],S_OUT));(D > 3, newScene(_,_,W,[1|_],[E|_],S_OUT));(newScene(_,_,W,[A|_],[E|_],S_OUT))),!.
createScene(H,W,_,D,_,S_OUT):-    number(W),number(H),number(D),A is 5-D,((D < 2,newScene(_,H,W,[4|_],_,S_OUT));(D > 3, newScene(_,H,W,[1|_],_,S_OUT));(newScene(_,H,W,[A|_],_,S_OUT))),!.
createScene(H,W,E,_,_,S_OUT):-    number(H),number(E),number(W),E < W/2,newScene(_,H,W,_,[E|_],S_OUT),!.
createScene(_,W,_,D,_,S_OUT):-    number(W),number(D),A is 5-D,((D < 2,newScene(_,_,W,[4|_],_,S_OUT));(D > 3, newScene(_,_,W,[1|_],_,S_OUT));(newScene(_,_,W,[A|_],_,S_OUT))),!.
createScene(H,_,_,D,_,S_OUT):-    number(H),number(D),A is 5-D,((D < 2,newScene(_,H,_,[4|_],_,S_OUT));(D > 3, newScene(_,H,_,[1|_],_,S_OUT));(newScene(_,H,_,[A|_],_,S_OUT))),!.
createScene(_,W,E,_,_,S_OUT):-    number(E),number(W),E < W/2,newScene(_,_,W,_,[E|_],S_OUT),!.
createScene(H,W,_,_,_,S_OUT):-    number(H),number(W),newScene(_,H,W,_,_,S_OUT),!.
createScene(_,_,_,D,_,S_OUT):-    number(D),A is 5-D,((D < 2,newScene(_,_,_,[4|_],_,S_OUT));(D > 3, newScene(_,_,_,[1|_],_,S_OUT));(newScene(_,_,_,[A|_],_,S_OUT))),!.
createScene(H,_,_,_,_,S_OUT):-    number(H),newScene(_,H,_,_,_,S_OUT),!.
createScene(_,W,_,_,_,S_OUT):-    number(W),newScene(_,_,W,_,_,S_OUT),!.

% CHARACTERINTOMAP(H,W,LIST)
% META: DETERMINAR SI TODOS LOS PERSONAJES EN UNA LISTA OTORGADA ESTAN DENTRO DE LOS MARGENES DEL ESCENARIO AL QUE PERTENECEN.
% DOMINIO: ENTERO X ENTERO X LISTA

characterIntoMap(_,_,[]):-!.
characterIntoMap(H,W,[[_,C_H,C_W]|TAIL]):- H >= C_H, W >= C_W, C_H > 0, C_W > 0, characterIntoMap(H,W,TAIL).

% SAMETEAMSUPERPOSITION(LIST,LIST)
% META: DETERMINAR SI NO EXISTEN DOS PERSONAJES UBICADOS EN LA MISMA POSICION, EN UN MISMO EQUIPO.
% DOMINIO: LISTA X LISTA

sameTeamSuperposition([_|[]],[]):-!.
sameTeamSuperposition(LIST,[]):-[_|[TAIL_HEAD|TAIL_END]] = LIST,sameTeamSuperposition([TAIL_HEAD|TAIL_END],TAIL_END),!.
sameTeamSuperposition([[_,H_1,W_1]|T_1],[[_,H_2,W_2]|T_2]):- (H_1 \= H_2; W_1 \= W_2),sameTeamSuperposition([[_,H_1,W_1]|T_1],T_2),!.

% DIFFERENTTEAMSUPERPOSITION(LIST,LIST)
% META: DETERMINAR SI NO EXISTEN DOS PERSONAJES UBICADOS EN LA MISMA POSICION, EN DISTINTOS EQUIPOS.
% DOMINIO: LISTA X LISTA

differentTeamSuperposition([],_,_):-!.
differentTeamSuperposition([_|TAIL_1],[],MEMORY_LIST):-differentTeamSuperposition(TAIL_1,MEMORY_LIST,MEMORY_LIST),!.
differentTeamSuperposition([[_,H_1,W_1]|T_1],[[_,H_2,W_2]|T_2],MEMORY_LIST):- (H_1 \= H_2;W_1 \= W_2),differentTeamSuperposition([[_,H_1,W_1]|T_1],T_2,MEMORY_LIST),!.

% CHECKSCENE(SCENE)
% META: DETERMINAR SI UN ESCENARIO OTORGADO CORRESPONDE A UN ESCENARIO VALIDO, ES DECIR, QUE POSEA DIMENSIONES VALIDAS, ADEMAS DE NO POSEER PERSONAJES SOBREPUESTOS EN LA MISMA POSICION, NI FUERA DE LOS MARGENES DE ESTE.
% DOMINIO: SCENE

checkScene([_,H,W,[_|[A_HEAD|A_TAIL]],[_|[E_HEAD|E_TAIL]]]):-H>0,W>0,characterIntoMap(H,W,[A_HEAD|A_TAIL]),characterIntoMap(H,W,[E_HEAD|E_TAIL]),sameTeamSuperposition([A_HEAD|A_TAIL],A_TAIL),sameTeamSuperposition([E_HEAD|E_TAIL],E_TAIL),differentTeamSuperposition([E_HEAD|E_TAIL],[A_HEAD|A_TAIL],[A_HEAD|A_TAIL]),!.

% MOVEMEMBER(SCENE_IN,ID,DIRECTION,SEED,SCENE_OUT)
% META: ENTREGAR UN ESCENARIO, DONDE UN ALIADO DETERMINADO, ASOCIADO A UN IDENTIFICADOR OTORGADO, SE HAYA DESPLAZADO HACIA LA IZQUIERDA O DERECHA, CORRESPONDIENTEMENTE, Y EVALUAR LA VALIDEZ DE DICHO ESCENARIO RESULTANTE.
% DOMINIO: SCENE X ENTERO X ENTERO X SCENE

moveMember(S_IN,M,MOVE_DIR,_,S_OUT):-(MOVE_DIR = "R";MOVE_DIR = "r";MOVE_DIR = r;MOVE_DIR = "D";MOVE_DIR = "d";MOVE_DIR = d),getALLYnumber(Q_ALLY,S_IN),getALLY(M,S_IN,ALLY),moveCHARright(ALLY,ALLY_OUT),getALLYlist(A_LIST,S_IN),mod_recursiveCHAR(A_LIST,ALLY_OUT,LIST_OUT),modALLYmodule(S_IN,[Q_ALLY|LIST_OUT],S_OUT),checkScene(S_OUT),!.

moveMember(S_IN,M,MOVE_DIR,_,S_OUT):-(MOVE_DIR = "L";MOVE_DIR = "l";MOVE_DIR = l;MOVE_DIR = "I";MOVE_DIR = "i";MOVE_DIR = i),getALLYnumber(Q_ALLY,S_IN),getALLY(M,S_IN,ALLY),moveCHARleft(ALLY,ALLY_OUT),getALLYlist(A_LIST,S_IN),mod_recursiveCHAR(A_LIST,ALLY_OUT,LIST_OUT),modALLYmodule(S_IN,[Q_ALLY|LIST_OUT],S_OUT),checkScene(S_OUT),!.

/* SHOOT */

   /* CONSULTA EL VALOR QUE DEBE TOMAR SCENEOUT
      PARA CORRESPONDER AL ESCENARIO TRAS UN DISPARO */

/* UPDATE SCENE */

   /* CONSULTA EL VALOR QUE DEBE TOMAR SCENEOUT
      PARA SER EL ESTADO DEL ESCENARIO AVANZADO UN TIC */

/* SCENE TO STRING */

   /* CONSULTA EL VALOR QUE DEBE TOMAR SCENESTR PARA QUE EL
      PREDICADO, A PARTIR DE SCENE, SEA VERDADERO */

   /* NO USAR PREDICADOS WRITE Y DISPLAY DENTRO DE SCENE TO STRING
      YA QUE LA VARIABLE SCENESTR DEBE SER UN STRING QUE LUEGO SEA
      USADO POR EL PREDICADO WRITE O DISPLAY */

   /* EL STRING DEBE SER IMPRESO POR DICHAS FUNCIONES */
