% TDA: SCENE

% CONSTRUCTOR EN BASE DE CONOCIMIENTO:

% FORMATO DEL TDA:  [ID,HEIGHT,WIDTH,[QALLY,[ALLY_LIST]],[QENEMY,[ENEMY_LIST]],[QOBSTACLE,[0BSTACLE_LIST]]]

% CONSTRUCTOR:

newScene(I,H,W,[QA|_],[QE|_],[QO|_],[I,H,W,QA,QE,QO]).

% PERTENENCIA:

isScene(S_OUT):-is_list(S_OUT),length(S_OUT,6), [I,H,W,A,E,O] = S_OUT, (number(I),I > 0),(number(H),H > 0),(number(W),W > 0),(number(A),A > 0),(number(E),E > 0),(number(O),O > 0).

% SELECTORES:

getID(ID,S_OUT):-[ID|_] = S_OUT.

getHEIGHT(H,S_OUT):-[_,H|_] = S_OUT.

getWIDTH(W,S_OUT):-[_,_,W|_] = S_OUT.

getALLY(A,S_OUT):-[_,_,_,A|_] = S_OUT.

getENEMY(E,S_OUT):-[_,_,_,_,E,_] = S_OUT.

getOBSTACLE(O,S_OUT):-[_,_,_,_,_,O] = S_OUT.

% MODIFICADORES:

modID(S_IN,ID,S_OUT):-[_|T] = S_IN, [ID|T] = S_OUT.

modHEIGHT(S_IN,HEIGHT,S_OUT):-[I,_|T] = S_IN, [I,HEIGHT|T] = S_OUT.

modWIDTH(S_IN,WIDTH,S_OUT):-[I,H,_|T] = S_IN, [I,H,WIDTH|T] = S_OUT.

modALLY(S_IN,ALLY,S_OUT):-[I,H,W,_|T] = S_IN, [I,H,W,ALLY|T] = S_OUT.

modENEMY(S_IN,ENEMY,S_OUT):-[I,H,W,A,_,O] = S_IN, [I,H,W,A,ENEMY,O] = S_OUT.

modOBSTACLE(S_IN,OBSTACLE,S_OUT):-[I,H,W,A,E,_] = S_IN, [I,H,W,A,E,OBSTACLE] = S_OUT.

/* ESCENARIOS: */
/* 3 ESCENARIOS DE 5X10 */

/* 2 ESCENARIOS DE 10X12 */

/* 1 ESCENARIO DE 20X20 */

/* IMPLEMENTAR FUNCION CREATE SCENE */

   /* D AFECTA LA CANTIDAD DE PERSONAJES DEL EQUIPO
      DEL JUGADOR Y LA POSICIÓN DE LOS OBSTACULOS */

   /* SEMILLA USADA PARA GENERAR VARIABLES SEUDO ALEATORIAS:
      -POSICION DE OBSTACULOS */

   /* CHEQUEAR SI ES POSIBLE DISPONER A TODOS LOS
      ENEMIGOS EN DICHO ESPACIO */

   /* DE NO SER POSIBLE, RETORNAR NULO */

/* CHECK SCENE */

   /* RECIBE TDA SCENE */

   /* CONSULTAR SI UN ESCENARIO ES VALIDO */

      /* DIMENSIONES VALIDAS */

      /* ENTIDADES VALIDAMENTE UBICADAS,
         SIN SUPERPOSICIÓN ENTRE ELLOS */ 

/* MOVE MEMBER */ 
 
   /* CONSULTA SI ES POSIBLE MOVER UN PERSONAJE
      DE CIERTO EQUIPO EN CIERTA DIRECCION */

   /* VERIFICAR EL DESPLAZAMIENTO, IZQUIERDA O DERECHA */

   /* ENTREGA RESULTADO DE MOVIMIENTO POR MEDIO DE VARIABLE SCENEOUT */

/* SHOOT */

   /* CONSULTA EL VALOR QUE DEBE TOMAR SCENEOUT
      PARA CORRESPONDER AL ESCENARIO TRAS UN DISPARO */

/* UPDATE SCENE */

   /* CONSULTA EL VALOR QUE DEBE TOMAR SCENEOUT
      PARA SER EL ESTADO DEL ESCENARIO AVANZADO UN TIC */

/* SCENE TO STRING */

   /* CONSULTA EL VALOR QUE DEBE TOMAR SCENESTR PARA QUE EL
      PREDICADO, A PARTIR DE SCENE, SEA VERDADERO */

   /* NO USAR PREDICADOS WRITE Y DISPLAY DENTRO DE SCENE TO STRING
      YA QUE LA VARIABLE SCENESTR DEBE SER UN STRING QUE LUEGO SEA
      USADO POR EL PREDICADO WRITE O DISPLAY */

   /* EL STRING DEBE SER IMPRESO POR DICHAS FUNCIONES */
